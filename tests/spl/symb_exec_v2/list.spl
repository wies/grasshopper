options "-symbexec-v2"

include "../include/sllist_rec_symbexec.spl"

/*
lemma unfold_lseg(x: Node, y: Node)
  requires lseg(x, y) &*& x != y
  ensures acc(x.next) &*& lseg(x.next, y)
{
  unfold lseg(x, y);
}

lemma fold_left(x: Node, y: Node)
  requires acc(x.next) &*& lseg(x.next, y) &*& y != x
  ensures lseg(x, y)
{
  fold lseg(x, y);
}

lemma empty_list(x: Node)
  requires emp
  ensures lseg(x, x)
{
  fold lseg(x, x);
}

procedure delete(x: Node)
  requires lseg(x, null)
  ensures emp
{
  unfold lseg(x, null);
  if (x != null) {
    delete(x.next);
    free x;
  }
  fold lseg(x, null);
}

procedure test_frame(x: Node, y: Node, z1: Node, z2: Node)
  requires acc(x.next) &*& x.next == z1 &*& lseg(y, null)
  ensures acc(x.next) &*& x.next == z2 &*& lseg(y, null)
{
  x.next := z2;
}

procedure reverse(lst: Node) 
  returns (rev: Node)
  requires lseg(lst, null)
  ensures lseg(rev, null)
{
  rev := null;
  var curr := lst;
  unfold lseg(lst, null);
  while (curr != null) 
    invariant lseg(rev, null)
    invariant lseg(curr, null)
  {
    unfold lseg(rev, null);
    var tmp := curr;
    curr := curr.next;
    tmp.next := rev;
    rev := tmp;
    fold lseg(rev, null);
  }
  fold lseg(lst, null);
}
*/

/* todo: run this through viper */
function length(x: Node, y: Node) returns (res: Int)
  requires lseg(x, y)
  ensures x == y ==> res == 0
  ensures res >= 0
{
 // unfolding lseg(x, y) in x == y ? 0 : 1 + length(x.next, y);
 x == y ? 0 : 1 + length(x.next, y)
}

procedure concat(x: Node, y: Node)
  returns (z: Node)
  requires lseg(x, null) &*& lseg(y, null)
  ensures lseg(z, null)
  ensures z == (x == null ? y : x)
  ensures length(z, null) == old(length(x, null) + length(y, null))
{
  if (x == null) {
    return y;
  } else {
    unfold lseg(x, null); // x != null &*& acc(x.next) &*& lseg(x.next, null) &*& lseg(y, null)
    if (x.next == null) {
      unfold lseg(x.next, null);
      x.next := y;
      // with unfold lseg(x.next, null) :
      // x != null &*& x.next == y &*& acc(x.next) &*& old(x.next) == null &*& emp &*& lseg(y, null)
      // without unfold lseg(x.next, null) :
      // x != null &*& x.next == y &*& acc(x.next) &*& lseg(old(x.next), null) &*& lseg(y, null)
      fold lseg(x, null); // lseg(x, null) &*& lseg(old(x.next), null)   for tight semantics.
      return x;
    } else {
      var z1 := concat(x.next, y);
      //x.next := z1;
      fold lseg(x, null);
      return x;
    }
  }
}
