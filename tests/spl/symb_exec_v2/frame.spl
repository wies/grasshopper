options "-symbexec-v2"

procedure foo(a: Int) returns (b: Int)
  requires a == 2
  ensures b == 4

procedure pure_call(c: Int) returns (a: Int)
  requires c == 2
  ensures a == 4
{
  a := foo(c);
}

procedure pure_call2(c: Int, d:Int)
  requires c == 2 && d == c
  ensures c == 2 && d == 4
{
  d := foo(c);
}

procedure foo3(a: Int) returns (b: Int)
  requires a == 2
  ensures b == 4 && a == 3

procedure pure_call3(c: Int) returns (d: Int)
  requires c == 2
  ensures d == 4
{
  d := foo3(c);
}

procedure foo4(a: Int, b: Int) returns (c: Int)
  requires a < 2 && b < 5
  ensures c == 4

procedure pure_call4(d: Int, e: Int) returns (f: Int)
  requires d == 0 && e == 1 
  ensures f == 4
{
  f := foo4(d, e);
}

procedure foo5(a: Int, b: Int, c: Int) returns (d: Int, e:Int) 
  requires a == 0 && b == 1 && c == 2
  ensures d == 5 && e == 6

procedure pure_call5(f: Int, g: Int, h: Int) returns (x: Int, y: Int)
  requires f == 0 && g == 1 && h == 2 
  ensures x == 5 && y == 6 
{
  var i: Int;
  var j: Int;
  i, j := foo5(f, g, h);
  return i, j;
}

procedure pure_call6(f: Int, g: Int, h: Int) returns (i: Int, j: Int)
  requires f == 0 && g == 1 && h == 2 
  ensures i == 5 && j == 6 
{
  i, j := foo5(f, g, h);
}

/* test with acc predicates */
struct Node {
  var next: Node;
}

procedure foo_heap(x: Node, y: Node)
  requires acc(x.next)
  ensures acc(x.next) &*& x.next == y
{
  x.next := y;
}

procedure bar_heap(x: Node, y: Node)
  requires acc(x.next) &*& acc(y.next)
  ensures acc(x.next) &*& acc(y.next) &*& y.next == old(y.next)
{
  var z := y.next;
  foo_heap(x, y);
  pure assert (y.next == z);
}
